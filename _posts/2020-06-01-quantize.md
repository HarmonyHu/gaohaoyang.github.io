---
layout: post
title: quantize int8
categories: AI
tags: 算法
---

* content
{:toc}
## 相关函数

### cmath

#### std::round

`double round(double x)`

四舍五入，比如：`std::round(7.479) = 7`, `std::round(7.579) = 8`

#### std::floor

`double floor(double x)`

取整，但`<= x`，比如：`std::floor(7.579) = 7`

#### std::frexp

`double frexp(double x, int *y)`

二进制浮点表达转换，若`w = std::frexp(x, &y)`，则`x = w * (2^y)`，w范围：`(-1.0, -0.5] U [0.5, 1.0)`

### algorithm

#### std::min_element / std::max_element

```c++
template< class ForwardIt > 
ForwardIt min_element( ForwardIt first, ForwardIt last );
template< class ForwardIt, class Compare >
ForwardIt min_element( ForwardIt first, ForwardIt last, Compare comp );
```

查找最小/最大元素

## 相关算法

#### threshold

有float运算：`Y = F(X)`，转换为int8运算：令`y = Y / threshold_y * 128`，`x = X / threshold_x * 128`，其中`threshold_y >= Y && threshold_x >= X`，

则int8运算：`y = f(x), Y = y * threshold_y / 128`

#### QScale

`QScale = Multiplier / ( 1 << LShift)`

其中QScale为float，Multiplier和LShift为int，将浮点转为整形运算。

通常为了确保精度，Multiplier取值范围`[64, 128)`，即：

`QScale * (1 << LShift) < 128` 且`QScale*(1 << (LShift+1)) >= 128`

#### Add推导

$$
Y= X_1 + X_2 + X_3 (float) \\
=> y \frac{thy}{128} = x_1 \frac{thx_1}{128} + x_2 \frac{thx_2}{128} + x_3 \frac{thx_3}{128} \\
=> y = x_1 \frac{thx_1}{thy} + x_2 \frac{thx_2}{thy} + x_3 \frac{thx_3}{thy} \\
=> y = x_1 Q_{scale1} + x2 Q_{scale2} + x3 Q_{scale3} \\
取 Q_{scale1}、Q_{scale2}、Q_{scale3}中最大LShift \\
=> y = x_1 \frac{M_1}{1<< LShift} + x_2 \frac{M_2}{1<<LShift} + x_3 \frac{M_3}{1<<LShift} (int8)
$$

